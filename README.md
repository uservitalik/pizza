# pizza


<<<<<<< HEAD Авторские права (R) 2025,
Авторские права (R) 2025,

vitali/master Все права защищены.

Распространение и использование в исходном и двоичном виде, с модификациями или без них, разрешается при соблюдении следующих условий:

Распространения исходного кода должны содержать указанное выше уведомление об авторских правах, этот список условий и следующий отказ от ответственности. Распространения в двоичной форме должны воспроизводить указанное выше уведомление об авторских правах, этот список условий и следующий отказ от ответственности в документации и/или других материалах, предоставленных вместе с распространением.

<<<<<<< HEAD Ни имя ivakhnenkovitali, ни имена его участников не могут быть использованы для одобрения
Ни имя ivakhnenkovitali, ни имена его авторов не могут быть использованы в целях одобрения

vitali/master или продвигать продукты, полученные с помощью этого программного обеспечения, без специального предварительного письменного разрешения.

ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ ВЛАДЕЛЬЦАМИ АВТОРСКИХ ПРАВ И УЧАСТНИКАМИ «КАК ЕСТЬ», И ЛЮБЫЕ ЯВНЫЕ ИЛИ ПОДРАЗУМЕВАЕМЫЕ ГАРАНТИИ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ, ПОДРАЗУМЕВАЕМЫЕ ГАРАНТИИ ТОВАРНОЙ ПРИГОДНОСТИ И ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ, ОТКАЗЫВАЮТСЯ. Ни при каких обстоятельствах владелец авторских прав или его соавторы не будут нести ответственности за любые прямые, косвенные, случайные, особые, образцовые или косвенные убытки (включая, помимо прочего, закупку заменяющих товаров или услуг; потерю использования, данных или прибыли; или перерыв в работе), как бы они ни были вызваны и по любой теории ответственности, будь то по договору, строгая ответственность или деликт (включая халатность или иное), возникающие каким-либо образом из-за использования этого программного обеспечения, даже если они были предупреждены об этом.



Авторское право (R) 2025,
Alle Rechte vorbehalten.

Die Redistribution und Nutzung in Quell- und Binärformen, mit oder ohne Änderungen, sind gestattet, sofern die folgenden Bedingungen erfüllt sind:

Die Weiterverbreitung des Quellcodes muss den oben genannten Copyright-Hinweis, diese Liste der Bedingungen und den folgenden Haftungsausschluss beibehalten. Die Weiterverbreitung в двоичной форме должен быть создан в соответствии с авторскими правами, этот Liste der Bedingungen und den folgenden Haftungsausschluss в документации и/или других материалах, die mit der Verteilung bereitgestellt werden, wiedergeben.

Weder der Name ivakhnovovitali.com noch die Namen seiner Mitwirkenden dürfen verwendet werden, um Produkte, die aus dieser Software abgeleitet sind, ohne ausdrückliche vorherige schriftliche Genehmigung zu unterstützen or zu bewerben.

ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ, КОТОРОЕ ЗАЩИТА АВТОРСКИХ ПРАВ, И ПРАВА НА ПРАВА, И ВСЕ ДОПОЛНИТЕЛЬНЫЕ ГАРАНТИИ, НЕОБХОДИМЫЕ ГАРАНТИИ, НЕОБХОДИМЫЕ УСЛОВИЯ ГАРАНТИЯ МАРКЕТИНГА И ПРАВИЛА ДЛЯ ЛУЧШЕГО ЦВЕТА, ВЕРНУТЬСЯ В РУКОВОДСТВО. IN KEINEM FALL HAFTEN DIE INHABER ODER MITWIRKENDEN FÜR DIREKTE, INDIREKTE, NEBENSÄCHLICHE, BESONDERE, MUSTERHAFTIGE ODER FOLGESCHÄDEN (EINSCHLIESSLICH, ABER NICHT BESCHRÄNKT AUF, DEN ERWERB VON) ERSATZGÜTERN ODER DIENSTLEISTUNGEN VERLUST VON GEBRAUCH, DATEN ODER GEWINNEN ODER UNTERBRECHUNG DES GESCHÄFTSBETRIEBS), UNABHÄNGIG VON DER URSACHE UND JEDER HAFTUNGSTEORI, OB IN VERTRAG, STRIKTER HAFTUNG ODER DELIKT; (EINSCHLIESSLICH FAHRLÄSSIGKEIT ODER ANDERWEITIG), DIE AUF IRGENDEINE WEISE AUS DER NUTZUNG DIESER SOFTWARE ENTSTEHT, SELBST WENN AUF DIE MÖGLICHKEIT HINGEWIESEN WURDE.



Ввод SVG

Ввод SVG

Ввод SVG

Ввод SVG

Ввод SVG

Кухня-кафе запуск ЮЗЕРА

https://www.youtube.com/watch?v=0ABftQLyHfs&t=109s

запускаю и работаю https://www.youtube.com/watch?v=mhTtMqqpajg

02

03

пи_1

пи_2

ба_1

кафе_1

п01

р02

р03

п04

бд

адрес

админ

Ввод SVGна основе архетипа maven -archetype -webapp архетипа и попробуем+его реализовать на последней версии LTS Java. Это версия JDK Development Kit 17.0.9. (можно скачать с оффсайта Oracle версию Open JDK). Архитип Maven – это структура папок и файлов проекта, которые использовались при создании проекта. После того, как maven завершил генерацию проекта, чистим файл pom.xml от лишнего, устанавливаем 17 уровень компайлера и подключаем jetty-maven-plugin (11.0.18). В

Эта версия JDK Development Kit 17.0.9. (можно рассылать по официальному сайту Oracle с версией Open JDK). Архетип Maven – это структура обучения и файлов проекта, которые выкарыстоўваются при создании проекта. После этого, как Maven скончал генерацию проекта, файл pom.xml с текстом, мы устали от 17-го уровня кампайлера и подключаем jetty-maven-plugin (11.0.18).

Это первая версия комплектов разработки JDK 17.0.9. (Открытая версия JDK может быть открыта на официальном веб-сайте Oracle). Das Maven-Archetyp ist die Ordner- und Dateistruktur eines Projects, die beim Erstellen eines Projekts verwendet wird. Nachdem Maven die Projekterstellung abgeschlossen Hat, bereinigen wir die pom.xml-Datei von unnötigem Inhalt, setzen das Compiler-Level auf 17 and fugen das jetty-maven-plugin (11.0.18) здесь.

Это версия 17.0.9 JDK Development Kit. (Вы можете загрузить версию Open JDK с официального сайта Oracle). Архетип Maven — это структура папок и файлов проекта, используемая при создании проекта. После того, как Maven закончит генерацию проекта, мы очищаем файл pom.xml от ненужных частей, устанавливаем уровень компилятора на 17 и добавляем jetty-maven-plugin (11.0.18).

fgdfdg

ск

4.0.0

<groupId>by.itclass</groupId>
<artifactId>final_project_2211</artifactId>
<version>1.0-SNAPSHOT</version>
<packaging>war</packaging> //файл будет упаковываться в war архив

<name>final_project_2211 Maven Webapp</name>

<properties>
    <project.build.sourceEncoding>UTF8</project.build.sourceEncoding>
    <maven.compiler.source>17</maven.compiler.source>
    <maven.compiler.target>17</maven.compiler.target>
</properties>
// в зависимостях – прописываем пакеты, которые будут подключены org.projectlombok lombok 1.18.30 предоставлен jakarta.servlet jakarta.servlet-api 6.0.0 предоставлен com.mysql mysql-connector-j 8.0.33 org.glassfish.web jakarta.servlet.jsp.jstl 2.0.0

</dependencies>

<build>
    <finalName>final_project_2211</finalName>
    <plugins>
        <plugin>
            <groupId>org.eclipse.jetty</groupId>
            <artifactId>jetty-maven-plugin</artifactId>
            <version>11.0.18</version>
        </plugin>
    </plugins>
</build>
Убеждаемся, что у нас установлен 17 уровень для компилятора Java в свойствах Intellij Idea (сборка, выполнение, развертывание -> Компилятор -> Компилятор Java). Убеждаемся, что у нас включена обработка аннотаций (сборка, выполнение, развертывание -> компилятор -> обработчики аннотаций). Убеждаемся, что у нас установлен 17 уровень Java для maven runner (Сборка, Выполнение, Развертывание -> Инструменты сборки -> Maven -> Runner). Убеждаемся, что у нас выбрана 17 версия Java SDK и уровень языка в свойствах проекта (Файл -> Структура проекта -> Настройки проекта -> Проект). Убеждаемся, что у нас установлен 17 уровень языка в свойствах модуля (Файл -> Структура проекта -> Настройки проекта -> Модули). Зависимости – SDK 17 Создаем все необходимые каталоги (java и ресурсы) Не забываем:
// чтобы заработала пристань - такая форма

Определились, что будем работать по моделям MVC.

Как я раньше говорил - в описании проекта нужно начать с описания бизнес-объектов, поэтому создадим нашу первую бизнес-сущность... это будет пользователь User... Для этого в пакете model.entities создадим класс User.

@AllArgsConstructor @RequiredArgsConstructor @Data public class User { private int id; private final String login; private final String name; private final String email; }

И хоть у нас и будет использован пароль, но обычно он не включается как поле класса, а просто хранит в базе данные...

Теперь приступим к реализации механизма авторизации на основе сервлетов и jsp. Задача сервлета получить параметры и передать их.

Чтобы не путаться в именах входов в форме и параметрах сервлетов (ведь они должны быть одинаковыми) – мы будем сохранять значения в классах констант... это позволяет также учитывать магические числа и литеральные константы.

Созданы в by.itclass.constants классы для хранения наград для Фронта и Бэка:

public class JspConstants { public static final String LOGIN_PARAM = "логин"; public static final String NAME_PARAM = "имя"; public static final String PASS_PARAM = "пароль"; public static final String EMAIL_PARAM = "электронная почта";

public static final String MESSAGE_ATTR = "message";
}

открытый класс ApplicationConstants {

}

Сервлетов у нас будет много... и для того, чтобы избежать дублирования кода, созданного в пакете by.itclass.controllers контурный сервлет, от которого мы найдем необходимые методы и поля. Для возможности наследования от класса HttpServlet необходимо в pom.xml добавить ограничение (уже добавлено)

jakarta.servlet jakarta.servlet-api 6.0.0 предоставлен
@WebServlet(имя = "abstractController")

@WebServlet (name='' AbstractController") // в абстрактном сервлете нет urlpattern public Abstract class AbstractController расширяет HttpServlet { // переопределяем метод doGet, который будет работать с doPost, метод doPost я @Override protected void doGet (HttpServletRequest req, HttpServletResponse resp) бросает ServletException, IOException { doPost(req, resp); }

//просто перейти на некий адрес
// создаётся объект, который позволяет передать информацию через req и resp, с помощью вызова метода перенаправление – который и перенаправит на другой адрес public void forwardUrl (HttpServletRequest req, HttpServletResponse resp, String url) бросает ServletException, IOException { req.getRequestDispatcher (url).forward(req, resp); }

//перегруженный метод... перейти с сообщением,
// setAttribute – закинет наше сообщение в атрибуты и перенаправит запрос

public void forwardUrl(HttpServletRequest req, HttpServletResponse resp,
                       String url, String message) throws ServletException, IOException {
    req.setAttribute(MESSAGE_ATTR, message);
    forwardUrl(req, resp, url);
}
Для хранения бизнес-объектов нашего приложения мы будем использовать базы данных... Как мы помним, для того чтобы подключиться к нашей базе данных необходимо привести некоторые телодвижения, а именно: Добавить в pom.xml условие, чтобы подключить пакет для работы с MySQL(подключен)

com.mysql mysql-connector-j 8.0.33
Создать класс ConnectionManager, в котором будет метод, возвращающий объект класса Connection. Для этого создаем в by.itclass.model.db и сам класс ConnectionManager. Можно пойти простым путём и написать примерно такое...

@UtilityClass public class ConnectionManager { // можно было вынести в свойства файла КОД НИЖЕ psfs DRIVER_NAME = "com.mysql.cj.jdbc.Driver"; URL-адрес psfs = "jdbc:mysql://localhost:3306/pizza_db"; psfs ПОЛЬЗОВАТЕЛЬ = "корень"; psfs ПАРОЛЬ = "";

private static Connection cn;
/

public static void init() {// обработать в try
    Class.forName(DRIVER_NAME);
}

public static Connection getConnection() throws SQLException {
    return Objects.isNull(cn) || cn.isClosed()
            ? DriverManager.getConnection(URL, USER, PASSWORD)
            : cn;
// } }

Но я предлагаю немного усложнить код и использовать другой подход. Для этого воспользуемся методом, при котором будем хранить параметры для подключения к базе данных в файле db.properties. В каталоге ресурсов создадим файл db.properties (Файл->Новый -> Проект ->Pesource Bundle !!!!!! или прописать путь без db – смотрите правильный адрес) следующим образом:

driver=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3306/po_pizza_17_version user=root пароль= Из этого файла мы будем получать объект очень хорошей коллекции Properties. Чем удобна эта коллекция – у нее есть метод, который позволяет данным, полученным из файла, заполнить коллекцию. Для того чтобы прочитать db.properties в пакете by.itclass.model.db создадим класс PropertiesManager и у него создадим метод getProperties(…), в параметрах получим константу, которая будет ссылаться на файл db.properties. // т.к. файл лежит не в директории Java, то считывание будет через FileReader будет организовано через Thread.currentThread() – возвращает текущий поток.

@UtilityClass public class PropertiesManager {публичные статические свойства getProperties(String fileName) {var props = new Properties(); попробуйте (var fr = new FileReader(Thread.currentThread().getContextClassLoader().getResource(fileName).getPath())) {props.load(fr); // прочитает файл из ресурса и сделает(вернет) его из объекта return props } catch (IOException e) { e.printStackTrace(); } вернуть реквизит; } } Для чего такой сложный код в методе – при компиляции наш файл db.properties открывается в target в каталоге с файлами, для того чтобы PropertiesManager мог найти этот файл, который мы должны вызвать в методе .getContextClassLoader()

@UtilityClass public class ConnectionManager { private static final String DRIVER = "driver"; private static final String URL = "url"; private static final String DB_FILE_PROPS = "db.properties";

private static Connection cn; // хранит ссылку на объект
private static Properties props; // коллекция которая будет создана

public static void init() {
   loadProps(); // создаст properties
   loadDriver(); // загрузит драйвер
} Public static void loadDriver() { try { Class.forName(props.getProperty(DRIVER)); } catch (ClassNotFoundException e) { e.printStackTrace(); } } Создан метод getConnection, который проверяет, есть ли объект isNull и не закрыт ли он isClosed. Если все хорошо получите соединение с БД.

public static Connection getConnection() throws SQLException {
   return Objects.isNull(cn) || cn.isClosed()
       ? DriverManager.getConnection(props.getProperty(URL), props)
       : cn;
}
} Далее это будет рефакториться, поскольку такой метод хорош при одном контроллере... а вот если их много, а по определению все наши контроллеры наследуются от абстрактного, то нету гибкости – поскольку мы тупо всегда будем получать коннекшен к MySql...

Опять же... пишем приложение на основе паттерна MVC – мы создаем все слои... сервис, дао... т.к. у нас должна быть прослойка между сервлетами и моделью (т.е. сервис - получает параметры от сервлета и на основе этих параметров вы выбираете соответствующий метод в dao и dao –по этому dao должен соединяться с сервисом) (Хотя в нашем сервисе, если уровни слоев и необязательны) первым создадим класс UserDao в пакете model.dao

открытый класс UserDao { частный статический UserDao dao;

private UserDao() {
    ConnectionManager.init(); // чтобы сработал dao вызываем метод init() из др класса
}
// проверит есть ли дао, если нет создателя public static UserDao getInstance() { return Objects.isNull (dao) ? новый UserDao(): дао; }

// проверит есть ли пользователь с таким логином и паролем public User getUser (String login, String пароль) { return null; } // проверит добавлен ли Пользователь в БД public boolean addUser (Пользователь-пользователь, Строковый пароль) { return true; } }

То же самое происходит в этом классе... при создании объекта этого класса возникает метод класса ConnectionManager, который создает свойства объекта и загружает в память драйвер), после чего мы можем получить соединение с базой данных....

Далее напишем класс UserService в пакете model.services

публичный класс UserService { частная статическая служба UserService; частная служба UserDao dao;

public UserService() {
    dao = UserDao.getInstance(); //конструктор вызовет др метод
}
// проверит есть ли сервис, если нет создателя

public static UserService getInstance() {
    return Objects.isNull(service) ? new UserService() : service;
}
// вернет пользователя, перейдем в классUserDao и там реализован метод

public User getUser(String login, String password) {
    return dao.getUser(login, password);
}
// добавит пользователя, перейдем в классUserDao и там реализован метод public boolean addUser(User user, Stringpassword) { return dao.addUser(user,password); } }

Ну и напишем первый контроллер для работы с пользователями в пакете Controllers.user. В пользователе будут храниться сервлеты, которые будут присутствовать при входе, выходе, регистрации. Перед написанием добавим в нашу константу URL-адрес приложения ApplicationConstants класс контроллера

public class ApplicationConstants { // для сервлетов public static final String LOGIN_CONTROLLER = "/login"; public static final String USER_NOT_FOUND = "Пользователь не найден"; }

а в классе константы нашего фронта class JspConstants

публичная статическая финальная строка MESSAGE_ATTR = "сообщение"; публичная статическая финальная строка USER_ATTR = "пользователь";

общедоступная статическая финальная строка LOGIN_JSP = "/jsp/login.jsp"; // путь, где будут храниться наши странички public static Final String HOME_JSP = "/jsp/home.jsp";

Реализация контроллера

В пакете контроллеров создаем пакет Пользователь

@WebServlet(urlPatterns = LOGIN_CONTROLLER) public class LoginController extends AbstractController { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { var login = req.getParameter(LOGIN_PARAM); var password = req.getParameter(PASS_PARAM);

    var user = userService.getUser(login, password);
    if (!Objects.isNull(user)) {
        var session = req.getSession();
        session.setAttribute(USER_ATTR, user);
        forwardUrl(req, resp, HOME_JSP);
    } else {
        forwardUrl(req, resp, LOGIN_JSP, USER_NOT_FOUND);
    }
}
} // Из первой страницы мы получаем объекты логина и пароля (т.е. то, что ввел пользователь) через getParameter. Обратимся к userService.getUser и передадим наши объекты(логин и пароль). Сервис обращается к дао….. и вернет пользователя. Т.к. у нас работает один пользователь с if и проверяем, есть ли у нас пользователь в БД. Если да – сохраним его в сеансе и перенаправим на страницу «Домой». Если такого пользователя нет, то перенаправим пользователя на первую страничку (регистрацию) и напишем сообщение об Нужны.

Инициализация UserService вынесена в абстрактный класс AbstractController (добавим поле userService и метод init

защищенный UserService userService;

@Override public void init() выдает исключение ServletException { userService = UserService.getInstance(); }

Напишем страницу – home.jsp, в каталоге /jsp, на котором мы будем отображать информацию о пользователе, если он найден

<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<title>Главная страница</title>
Информация о пользователе
логин: ${user.login}

имя: ${имя_пользователя}

электронная почта: ${user.email}

Ну и конечно же напишем страницу, на которой пользователь может снизить авторизацию – login.jsp. <%@ page import="constants.ApplicationConstants" %> <%@ page import="constants.JspConstants" %> <%@ page contentType="text/html;charset=UTF-8" Language="java" %> <%@ taglib prefix="c" uri=" http://java.sun.com/jsp/jstl/core " %>

<title>Страница входа</title>
Авторизоваться
${сообщение}
Для того, чтобы было красиво, добавим немного стилей... тем более, что мы их уже подключили на странице – файлstyles.css в директории /css. .form-box {выравнивание текста: центр;
цвет фона: светло-серый;
граница: 10 пикселей, сплошная зеленая;
поле: 20 пикселей;
осталось: 35%; позиция: абсолютная; ширина: 300 пикселей; отступ: 50 пикселей; верх: 30%; }

ввод{ ширина: 200 пикселей;
поле: 5 пикселей; отступ: 5 пикселей; }

input[type=submit]{ ширина: 120 пикселей;
граница: нет;
отступы: 16 пикселей 32 пикселя;
поля: 4 пикселя 2 пикселя;
цвет фона: зеленый; цвет: белый; оформление текста: нет; курсор: указатель; }

.error{ цвет: красный; }

Ну и наконец-то перейдем к реализации метода дао, а именно метода поиска пользователя в базе данных. Создаем еще один файл с константами... в нем мы будем хранить все для работы с базой данных. DbConstants psfs ID_COL = "id"; psfs LOGIN_COL = «вход»; psfs NAME_COL = "имя"; psfs PASS_COL = «пароль»; psfs EMAIL_COL = "электронная почта"; psfs PRICE_COL = «цена»;

// описываем наш запрос psfs SELECT_USER = "ВЫБЕРИТЕ идентификатор, имя, адрес электронной почты ОТ пользователя WHERE логин = ? И пароль =?";

Ну и сама реализация метода в классе UserDao:

public User getUser(String login, String пароль) { try (var cn = ConnectionManager.getConnection(); // соединение с коннекшинами var ps = cn.prepareStatement(SELECT_USER)) {// запрос запроса (существующий 2 метод) // значение вопросов в полях, сколько вопросов в запросе и ps ps.setString(1, login);// setString т.к. логин – имеет тип String ps.setString(2,пароль); setString т.к. пароль – имеет тип String СМОТРИ ТИП ПОЛЕЙ var resultSet = ps.executeQuery(); //создание таблицы соответствия if(resultSet.next()) { //т.к. речь идет об одном пользователе, поэтому через if var id = resultSet.getInt(ID_COL); имя вар = resultSet.getString(NAME_COL); вар электронная почта = resultSet.getString(EMAIL_COL); вернуть нового пользователя (идентификатор, логин, имя, адрес электронной почты); //вернет пользователя } } catch (SQLException e) { e.printStackTrace(); } Вернуть ноль; // если нет вернет null }

Для создания проверок используем ресурсы данных po__17_version

СОЗДАТЬ БАЗУ ДАННЫХ po_17_version;

в базе данных создаем пользовательскую таблицу, с соответствием полям

Авторизация возможна PS и даже если закрыть все окна браузера, юзер сохранится в сессии....

Работа с пользователями будет состоять из трех процессов, один из которых мы уже реализовали.. приступим к реализации второго (выход) для этого создадим новый сервлет. Для вывода – нужно удалить все данные, которые хранятся на расстоянии... т.е. тупо закрыть сессию. Инвалидируемую сессию и делает редирект не путать с вперед и переадресует на страницу логина. Это убъет сведения обо всех действиях... В абстрактном контроллере создан метод redirect():

protected void redirect (HttpServletResponse resp, String url) выдает IOException { resp.sendRedirect(getServletContext().getContextPath() + url); // sendRedirect – переадресует // getServletContext – некая папка, которая хранится и создается на пространстве, в котором будет деплоиться наш контекст // getContextPath – путь к контексту }

добавить в файл ApplicationConstants константу новый путь к сервлету..

psfs LOGOUT_CONTROLLER = "/logout";

и в нашем пакете Controllers.user создаем новый класс сервлета LogoutController и переопределяем метод doPost этот метод...

@WebServlet (urlPatterns = LOGOUT_CONTROLLER) общественный класс LogoutController расширяет AbstractController { @Override protected void doPost (HttpServletRequest req, HttpServletResponse соответственно) выдает ServletException, IOException {var session = req.getSession(); сеанс.инвалидата(); resp.sendRedirect(LOGIN_JSP); } } Вспоминаем отличие форварда от редиректа – форвард подает заявку на передачу пары запрос-ответ внутри приложения... и клиент даже не подозревает об этих передачах и при получении ответа на вопрос, что он получил от ресурса, у которого он и запрашивал информацию. Метод sendRedirect содержит в себе информацию о ресурсе, на который будет перенаправление, но он просит клиента отправить на эту страницу новую пару запросов-ответов, о старой паре забывает... т.е. браузер формирует новый запрос (юзер также может не знать об этом, но форма нового запроса)!!! Поскольку перенаправление работает и происходит с опозданием, необходимо пройти полный путь... именно поэтому нужны были танцы в сервлете (контекст).

И добавим на home.jsp ссылку на ЛОГАУТ КОНТРОЛЛЕР

<%@ страница import="by.itclass.constants.ApplicationConstants"%> <%@ страница contentType="text/html;charset=UTF-8" language="java"%>

<title>Главная страница</title>
Выйти

Информация о пользователе
логин: ${user.login}

имя: ${имя_пользователя}

электронная почта: ${user.email}

Выход готов PS проверить легко – если не нажимаем на выход из системы, просто закройте вкладку, а потомки преступники перейдите по ссылке /jsp/home.jsp - чтобы получить информацию о пользователе будет Google... если же нажать выход - то работы не будут Ну и третий этап с юзерами – это регистрация. Регистрацию пользователя пользователя также как и вход в систему мы производим с помощью форм. Для этого создадим в каталоге /jsp страницу для регистрации Registration.jsp, практически скопировав вход в страничку, просто экшен в форме будет другой, а поля в форме будет больше.

<title>Страница регистрации</title>
Регистрация
${сообщение}
И добавим новые пути в константы в классе ApplicationConstants psfs REGISTRATION_CONTROLLER = "/registration"; psfs USER_NOT_REGISTERED = "Регистрация не удалась";
и в классе константы JspConstants psfs REGISTRATION_JSP = "/jsp/registration.jsp";

Итак... страница отправляет запрос на контроллер, который мы и должны создать...

@WebServlet(urlPatterns = REGISTRATION_CONTROLLER) public class RegistrationController extends AbstractController { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { var login = req.getParameter(LOGIN_PARAM); var name = req.getParameter(NAME_PARAM); var password = req.getParameter(PASS_PARAM); var email = req.getParameter(EMAIL_PARAM); var user = new User(login, name, email); if (userService.addUser(user, password)) { redirect(resp, LOGIN_JSP); } else { forwardUrl(req, resp, REGISTRATION_JSP, USER_NOT_REGISTERED); }

}
} Добавим новый запрос в константы DbConstants psfs INSERT_USER = "INSERT INTO значения пользователя (имя, адрес электронной почты, логин, пароль) (?, ?, ?, ?)"; и в классе UserDao переопределим метод, который будет добавлять пользователя в ресурсы данных и возвращать нам булево значение... В этом же классе напишем метод, который будет проверять занятость входа в систему. Для этого метода также добавим константу строки запроса DbConstants.

psfs SELECT_USERID_BY_LOGIN = "ВЫБРАТЬ id ИЗ пользователя, ГДЕ логин = ?";

и наконец... методы реализации в UserDao

public boolean addUser(Пользователь-пользователь, пароль String) { try (var cn = ConnectionManager.getConnection(); var ps = cn.prepareStatement(INSERT_USER)) { if (isAccessible(user.getLogin(), cn)) { ps.setString(1, user.getName()); ps.setString(2, user.getEmail()); ps.setString(3, user.getLogin()); ps.setString(4, пароль); вернуть ps.executeUpdate() > 0; // если был добавлен пользователь, выполнитьUpdate вернет логическое значение 1 – это значит, что добавлено } } catch (SQLException e) { e.printStackTrace(); } Вернуть ложь; // если не 1 (это значит не добавлено) }

// проверит не занят ли вход в БД (он ходит в БД и проверяет только вход , остальное нас не интересует по задаче, можно добавить лобое поле) // ПЕРЕДАЕМ Connection cn – чтобы не сохраняться, метод все равно работает с копией String login, Connection cn – поэтому Connection не закроется Private Boolean isAccessible(String Login, Connection cn) выдает SQLException { try (var ps = cn.prepareStatement(SELECT_USERID_BY_LOGIN)) { ps.setString(1, логин); return !ps.executeQuery().next(); // если такой логины нет – вернет false } catch (SQLException e) { e.printStackTrace(); } Вернуть ложь; // если такой логины нет – вернет false(ЧТОБЫ НЕ БЫЛО КОНФЛИКТА ДУБЛИРУЕМ) }

Все конечно работает, но куда приятней не писать пути вручную, а нажимать кнопки, поэтому сделаем файл Menu.jsp и будем его подключать на всех страницах В JspConstant пропиши константу меню.jsp public static Final String MENU_JSP = "/jsp/menu.jsp";

<%@ page import="by.itclass.constants.ApplicationConstants"%> <%@ page import="by.itclass.constants.JspConstants"%> <%@ page contentType="text/html;charset=UTF-8" language="java"%> <%@ taglib prefix="c" uri=" http://java.sun.com/jsp/jstl/core"%>

Индекс
Авторизоваться
Регистрация
Дом
Выйти
Дополним стили

.nav-ul{ list-style-type: none;
padding: 0;
background-color: gray; margin: 0; overflow: hidden; }

.nav-li{ float: right;}

.nav-li.float-left{ float: left;}

.nav-li a{ display: block;
text-align: center;
text-decoration: none; color: white; padding: 14px 16px; }

.nav-li a:hover:not(.active){ фоновый цвет: тусклый серый;}

.active { цвет фона: зеленый;}

В JspConstant пропиши константу menu.jsp public static Final String INDEX_JSP = "/index.jsp";

Создал стартовую страницу index.jsp и подключил к ней файл Menu.jsp с помощью директивы jsp:include.

<%@ страница import="by.itclass.constants.JspConstants" %> <%@ страница contentType="text/html;charset=UTF-8" language="java" %>

<title>Пицца_2211</title>


Самая вкусная пицца!!!
Добавить в файл JspConstants путь к картинке

public static final String BACKGROUND_IMAGE = "/img/pizza-dinner.jpg";

Добавим стили для картинок

.default-image {
ширина: 100%;
непрозрачность: 0,5; } Для картинок создадим отдельный каталог img и поместим туда фоновую картинку...

Также подключим файл Menu.jsp и поместим картинку на страницу login.jsp и Registration.jsp Стр11 и 12.

<jsp:include page="<%=JspConstants.MENU_JSP%>"/> 

И чтобы не было зазоров по бокам, добавьте стиль для элемента тела

тело { поле: 0 пикселей; } Итак, мы реализовали работу с пользователями, которая состоит из 3-х блоков – вход, регистрация и выход.

Приступим к написанию непосредственно в нашей пиццерии... 

Создал таблицу, в которой будем хранить позиции меню нашей пиццерии.

CREATE TABLE foodItem ( id int NOT NULL AUTO_INCREMENT PRIMARY KEY, foodTypeId int NOT NULL, name varchar(50) NOT NULL, price double NOT NULL );

INSERT INTO foodItem (foodTypeId, name, цена) ЗНАЧЕНИЯ (1, «Маргарита», 15,99), (1, «Наполетана», 17,99), (1, «Карбонара», 25,99), (1, «Пеперони», 25,99), (2, «Пиво», 9,50), (2, «Кола», 2,50), (2, «Чай», 3,50), (2, «Кофе», 9,50);

Создадим таблицы, в которых будут храниться заказы и позиции из этого заказа.

CREATE TABLE orders ( id varchar(50) NOT NULL PRIMARY KEY, date date NOT NULL, userId int NOT NULL, address varchar(50) NOT NULL, FOREIGN KEY (userId) REFERENCES user (id) ON DELETE CASCADE ON UPDATE RESTRICT );

CREATE TABLE orderItem ( orderId varchar(50) NOT NULL, itemId int NOT NULL, количество int NOT NULL, FOREIGN KEY (orderId) ССЫЛКИ на заказы (id) ПРИ УДАЛЕНИИ КАСКАДА ПРИ ОГРАНИЧЕНИИ ОБНОВЛЕНИЯ, ВНЕШНИЙ КЛЮЧ (itemId) ССЫЛКИ на foodItem (id) ПРИ УДАЛЕНИИ КАСКАДА ПРИ ОГРАНИЧЕНИИ ОБНОВЛЕНИЯ ); По традиции начнем с моделей, в пакете model.entities создадим класс FoodItem

@AllArgsConstructor @Data @EqualsAndHashCode public class FoodItem { private int id; private int type; private String name; private double price; }

Дополните наш файл menu.jsp кнопкой, которая будет отображаться только авторизованному пользователю, нажмите кнопку, с помощью которой он сможет просмотреть меню, предлагаемое пиццерией. (Пицца и Напитки)

    Пицца
    Напиток
И мы добавим в класс ApplicationConstants эти ссылки:

public static final String MENU_CONTROLLER = "/menu"; public static final String PIZZAS_MENU = "/menu?foodType=1"; public static final String DRINKS_MENU = "/menu?foodType=2";

Две последние ссылки сделаны так нарочно... нам нужно ввести сервлет и передать всего один параметр... этот параметр передаётся не с помощью формы, а напрямую в URL.

Как и с пользователем начать писать этот код, начиная с уровня DAO

открытый класс FoodDao { частный статический FoodDao дао;

    частный FoodDao() { ConnectionManager.init(); }

    public static FoodDao getInstance() { return Objects.isNull(dao) ? new FoodDao() : dao; }

    public List getFoodItemsByType(int foodType) { var items = new ArrayList(); try (var cn = ConnectionManager.getConnection(); var ps = cn.prepareStatement(SELECT_FOOD_ITEMS_BY_TYPE)){ ps.setInt(1, foodType); var resultSet = ps.executeQuery(); while (resultSet.next()) { var id = resultSet.getInt(ID_COL); var name = resultSet.getString(NAME_COL); var price = resultSet.getDouble(PRICE_COL); items.add(new FoodItem(id, foodType, name, price)); } } catch (SQLException e) { e.printStackTrace(); } return items; } } Дополним файл DbConstants

psfs PRICE_COL = «цена»; psfs SELECT_FOOD_ITEMS_BY_TYPE = "ВЫБРАТЬ идентификатор, имя, цену FROM foodItem WHERE foodTypeId =?"; соответственно сервис для сервлета:

публичный класс FoodService { частная статическая служба FoodService; частная служба FoodDao;

  private FoodService() { dao = FoodDao.getInstance(); } public static FoodService getInstance() { return Objects.isNull(service) ? new FoodService() : service; } public List getFoodItemsByType(int foodType) { return dao.getFoodItemsByType(foodType); } }

И когда вся логика по извлечению написана, приступим к сервлету, который нам будет доставать из базы данных данные айтемы, в зависимости от их типа. В пакете контроллеры.food создадим класс MenuController...

Инициализация сервиса, а также вынесение в абстракный сервлет

@WebServlet(value = MENU_CONTROLLER) public class MenuController extends AbstractController { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { var foodType = Integer.parseInt(req.getParameter(FOOD_TYPE_PARAM)); var items = foodService.getFoodItemsByType(foodType); enrichRequest(req, foodType, items); forward(req, resp, HOME_JSP); }

  private void enrichRequest(HttpServletRequest req, int foodType, List items) { switch (foodType) { case 1 -> req.setAttribute(PIZZA_ATTR, items); case 2 -> req.setAttribute(DRINK_ATTR, items); } } } Дополним класс JspConstants новыми константами

public static final String FOOD_TYPE_PARAM = "foodType"; public static final String PIZZA_ATTR = "пиццы"; public static final String DRINK_ATTR = "напитки";

Я выбрал для меню способ запроса вместо хранения его в сессии... мне это показалось более логичным. Поскольку мы хотим предоставить возможность просмотра меню только авторизованным пользователям, сервлет пересылает наш запрос на домашнюю страничку. Напишем тот же код, который покажет полученные данные. Не забываем, что файл home.jsp у нас уже создан... просто меняем его критерий

Привет, ${имя_пользователя}
Здесь можно разместить какой-то контент... например, слайдер...
 
Сегодня мы предлагаем следующие пиццы:
     
      пицца      
Имя: ${pizza.name}

     
Цена: ${pizza.price} за 1000 руб.

   
   
Сегодня мы предлагаем следующие напитки:
     
      напиток      
Имя: ${drink.name}

     
Цена: ${drink.price} за 1000 бат.

   
 
Добавим прекрасных стилей для более красивого показа

.food-item-box { background-color: lightgray; width: 200px; height: 251px; border: 3px solid green; padding: 15px; margin: 25px; display: inline-block; vertical-align: top; }

.маленькое-изображение { ширина: 200 пикселей; }

Конечно, показать меню – это достижение... но было бы прикольно и добавить что-нить в корзину... Чтобы нам было чего добавить – напишем класс OrderItem в пакете model.entities. Данный класс будет соблюдать осторожность по заказу восточного пункта меню, а также количество заказанных продуктов. 

@Data @EqualsAndHashCode @RequiredArgsConstructor public class OrderItem { private String orderId; private final FoodItem item; private final int quantity; }

Возможность заказать продукт организуем в видео-формах, которые поместим на нашу страницу home.jsp в каждом айтем меню. Для пиццы 

             
Для напитков 

             
Стили для форм input[type=number] { width: 45px; отступ: 5 пикселей; }

.food-item-box input[type=submit] { width: 100px; height: 30px; background-color: green; border: none; color: white; padding: 5px; text-decoration: none; margin-left: 35px; cursor: pointer; }

Данная форма будет передавать сервлету сведения о заказанном товаре и его количестве, таким образом формируя заказ. 

Поместим в класс ApplicationConstants адрес нового контроллера

публичная статическая окончательная строка CART_CONTROLLER = "/cart";

Дополним класс JspConstants новыми константами

public static final String FOOD_ID_PARAM = "id"; public static final String FOOD_NAME_PARAM = "name"; public static final String FOOD_PRICE_PARAM = "price"; public static final String FOOD_QUANTITY_PARAM = "quantity"; public static final String CARD_ACTION_PARAM = "cardAction"; public static final String ORDER_ITEMS_ATTR = "orderItems";

Вновь сначала напишем сервис и по привычке инициализируем его в абстрактном контроллере 

публичный класс CartService { частная статическая служба CartService;

  public static CartService getInstance() { return service == null ? new CartService() : service; }

  общедоступный список ProcessCard (сессия HttpSession, String cardAction, элемент OrderItem) {Object orderItems = session.getAttribute (ORDER_ITEMS_ATTR); Элементы списка = !Objects.isNull(orderItems)? (Список) orderItems: новый ArrayList<>(); переключатель (cardAction) {case "addToCard" -> items.add(item); случай "removeFromCart" -> items.remove(item); } вернуть элементы; } } Поскольку объекты хранятся в сеансах и обращение к внешнему БД нету, DAO не требуется. А вот и сам сервлет, его кстати напишем в пакете контроллеров/заказ

@WebServlet(value = CART_CONTROLLER) public class CartController extends AbstractController { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp){ var id = Integer.parseInt(req.getParameter(FOOD_ID_PARAM)); var foodType = Integer.parseInt(req.getParameter(FOOD_TYPE_PARAM)); var foodName = req.getParameter(FOOD_NAME_PARAM); var foodPrice= Double.parseDouble(req.getParameter(FOOD_PRICE_PARAM)); var foodQuant=Integer.parseInt(req.getParameter(FOOD_QUANTITY_PARAM)); var cardAction = req.getParameter(CARD_ACTION_PARAM); var item = new OrderItem( new FoodItem(id, foodType, foodName, foodPrice), foodQuant); var session = req.getSession(); var items = cartService.processCard(session, cardAction, item); session.setAttribute(ORDER_ITEMS_ATTR, items); if ("addToCard".equals(cardAction)) { redirectToMenuPage(resp, foodType); } else { redirect(resp, CART_JSP); } } private void redirectToMenuPage(HttpServletResponse resp, int foodType){ switch (foodType) { case 1 -> redirect(resp, PIZZAS_MENU); case 2 -> redirect(resp, DRINKS_MENU); } } }

Дополним наше меню Menu.jsp

       Корзина
Файл константы (JspConstants) public static Final String CART_JSP = "/jsp/cart.jsp";

И приступить к написанию странички, на которой мы сможем увидеть нашу корзину и иметь возможность удалить из корзины айтемы (для упрощения я не обращаю внимания на количество, которое вы можете сделать сами), тем более мы ее только что объявили в константах.

   
Привет, ${имя_пользователя}
           
Ваши позиции заказа:
             
                    
Вы заказали
я
т
е
м
.
д
ты
а
н
т
я
т
у
{item.item.name} от
я
т
е
м
.
я
т
е
м
.
п
г
я
с
е
б
у
н
.
А
м
о
ты
н
т
я
с
{количество.предмета * цена.предмета}
                     
            Сюда добавьте заказ – чутка дальше будет              
У вас нет товаров в заказе

      Стили:
.cart-item-container { высота: 80 пикселей; }

.cart-img { высота: 60 ​​пикселей; плавающее положение: левое; граница: 1 пиксель сплошной черный; поля: 5 пикселей 50 пикселей 10 пикселей 0 пикселей; }

.cart-текст { margin: 0 0 10px; }

.cart-item-container input[type=submit] { width: 140px; height: 35px; background-color: green; border: none; color: white; padding: 10px 10px; text-decoration: none; margin: 0px 3px; cursor: pointer; }

Все действия по добавлению и удалению позиций корзины пока периодически в сессии созданы для пользователя... на странице корзины мы также делаем возможность сабмитнуть наш заказ, предварительно введя адрес доставки – обратите внимание, что это поле сделано реквайред. 

Этот код представляет собой веб-приложение для пиццерии, реализованное на Java с использованием:

Технологии:

Java 17 (LTS)

Maven (архетип веб-приложения)

Jetty (встроенный сервер через jetty-maven-plugin)

API сервлета 6.0

JSP + JSTL

MySQL

Архитектура:

MVC-шаблон

Трехуровневая структура (Контроллеры → Службы → DAO)

Шаблон Singleton для сервисов и классов DAO

Основные характеристики:

Пользовательская система:

Регистрация

Авторизоваться

Выйти

Меню пиццерии:

Посмотреть пиццы и напитки

Добавить в корзину

Управление заказами:

Модификации корзины

Проверить

База данных:

Таблицы: пользователь, foodItem, заказы, orderItem

Подключение через ConnectionManager с db.properties

Ключевые детали реализации:

Абстрактный базовый сервлет

Обработка сеанса

Разделение констант

Ломбок для модельных классов

Комментарии на нескольких языках (хотя пользовательский интерфейс не локализован)

Код, указанный в веб-баннере для пиццерии, реализован на Java с:

Технологии:

Java 17 (LTS)

Maven (Веб-приложение-архетип)

Jetty (сервер eingebetteter через плагин jetty-maven)

API сервлета 6.0

JSP + JSTL

MySQL

Архитектура:

MVC-шаблон

Drei-Schichten-Struktur (Контроллер → Сервисы → DAO)

Шаблон Singleton для служб и DAO

Основные функции:

Система Benutzer:

Регистрация

Анмельдунг

Абмельдунг

Меню пиццерии:

Anzeige von Pizzen & Getränken

Warenkorb-Funktion

Bestellverwaltung:

Варенкорб-Анпассунген

Bestellabschluss

Датабанк:

Таблицы: пользователь, foodItem, заказы, orderItem

Подключение через ConnectionManager с db.properties

Особенности:

Абстрактер Basis-Servlet

Сессия-Verwaltung

Треннинг фон Константен

Ломбок для модельного класса

Дополнительные комментарии (UI не локализован)

Код представляет собой веб-приложение для пиццерии, разработанное на Java с:

Технологии:

Java 17 (LTS)

Maven (архетип веб-приложения)

Jetty (запуск сервера через jetty-maven-plugin)

API сервлета 6.0

JSP + JSTL

MySQL

Архитектура:

Модель MVC

Структура из трех диванов (Контроллеры → Сервисы → DAO)

Синглтон для служб и DAO

Основные функции:

Управление пользователями:

Надпись

Связи

Déconnexion

Меню пиццерии:

Affichage des Pizza & Boissons

Ajout au panier

Управление командами:

Модификация дю панье

Проверка

База данных:

Таблицы: пользователь, foodItem, заказы, orderItem

Подключение через ConnectionManager с db.properties

Подробности здесь:

Сервлет базы абстракции

Управление сессиями

Разделение констант

Ломбок для моделей

Многоязычные комментарии (нелокальный пользовательский интерфейс)

О
Описания, веб-сайта или тем не предоставлено.
Ресурсы
 Прочти меня
 Активность
Звезды
 3 звезды
Наблюдатели
 1 смотрит
Вилки
 0 вилок
Релизы
Нет опубликованных релизов
Создать новый релиз
Пакеты
Пакеты не опубликованы
Опубликуйте свой первый пакет
Участники
2
@ivakhnenkovitali
ivakhnenkovitali г -н
@test5User
test5Пользователь
Языки
Ява
92.9%
 
CSS
5.4%
 
Другой
1,7%
Предлагаемые рабочие процессы
На основе вашего технологического стека
Логотип AndroidCI
Android-CI-система
Создайте проект Android с помощью Gradle.
Логотип генератора SLSA Generic
Универсальный генератор SLSA
Сгенерируйте источник SLSA3 для ваших существующих рабочих процессов выпуска
Опубликовать пакет Java с логотипом Maven
Публикация пакета Java с помощью Maven
Создайте пакет Java с помощью Maven и опубликуйте его в GitHub Packages.
